---
title: "C언어 포인터"
date: "2022-02-03T18:56:00.000Z"
template: "blog"
draft: false
slug: "/blog/pointer/"
category: "C_lang"
description: "책, 인터넷 등을 통해 포인터에 대해 공부한 것을 정리해두었다. "
---

## Pointer
포인터도 일종의 `변수`이다. (변수와 같이 선언한 변수 타입에 따라) 특정한 데이터가 들어간다. 포인터는 그 특정 데이터가 저장된 `주소값`을 보관하는 변수이다.   
포인터의 정의는 `포인터에 주소값이 저장되는 데이터 타입* 포인터명` (데이터의 주소값을 저장하는 변수를 정의) 혹은 단항일 경우엔 `*포인터명`이다. `곱셈 연산자`가 아니다. 곱셈연산자와 달리 포인터 정의하는 연산자는 `1개의 피연산자`를 필요로 한다.    
포인터를 정의한 뒤 값을 넣어야 할 때 `& 연산자`를 이용한다. `피연산자가 2개 들어가는 AND연산자`와 달리 `1개의 피연산자`가 필요한다 `&주소값을 계산할 데이터`이렇게 정의하여 사용한다.
```c
#<stdio.h>
int main(void) {
  // 포인터 선언
  int *a;
  int* b;
  int *c, *d, *e;
  return 0;
}
``` 

### 포인터 장점 및 단점
#### 장점
포인터 변수는 4byte의 주소만 가지게 된다. 함수의 인자로 넘길경우 메모리 복사도 4byte 만큼만 일어나게 된다. 클래스 같이 큰 객체도 포인터형으로 전달될 경우 해당 메모리의 첫번째 주소값이 넘어가기 때문에 `불필요한 메모리 복사가 일어나지 않게 된다.`   
주소를 컨트롤 하므로 원본에 대한 값 변경이 용이하다. 데이터에 대한 접근이 빨라 처리속도가 나쁘지 않다.   
배열로 생성할 수 없는 데이터를 생성할 수 있다.
#### 단점
Null 포인터에 직접 접근 등의 `예외`에 대한 처리가 확실치 않는 경우 예기치 못한 문제가 발생할 수 있다. 또하누 오류를 범하거나 기교적인 프로그램이 되기 쉽다.     
주소를 직접 참조하기 때문에 의도치 않게 원본 값이 수정될 수 있고 선언만 하고 초기화 하지 않을 시 쓰레기 주소를 가리킨다.   
메모리 절대 번지 접근시 시스템 오류를 초래한다.
## 배열과 포인터
>배열은 간단하게 말하자면 같은 타입의 변수들의 집합이다.   
>언뜻 같은 듯 하지만 배열과 포인터는 완전히 같지 않다.

배열은 그 자체가 크기 때문에 함수 인자로 전달할 수 없다. 하여 `배열을 함수로 전달할 때 반드시 포인터를 사용`해야 한다.   
동작의 속도 차이가 있는데, 배열은 배열 선두부터 출발하지만 포인터의 경우 대상체로 직접 이동해서 읽으므로 포인터의 액세스 속도가 빠르다. `*p`는 p가 가리키는 곳을 바로 읽을 수 있는데 비해 배열은`(array[i]) *(array+i)` 이렇게 번지를 더한 후 읽어야 하므로 포인터보다 느릴 수 있겠다.   
`배열은 상수`, `포인터는 변수`이다. 포인터는 고유의 메모리를 차지하며 언제든 다른 대상을 가리킬 수 있으나 배열은 이미 해당 위치가 고정되어 있어 다른 대상을 가리킬 수 없으며 배열은 오직 배열의 선두 번지를 읽을 수 있다. 선언할 때 크기 지정도 `배열`의 경우 `선언시 정적으로 결정`되어야 하나 `포인터`는 `동적으로 선언`할 수 있다. 만일 가변길이 배열이 필요한 경우 int*형의 포인터 변수를 선언한 뒤 malloc으로 할당해 사용하여야 한다. 포인터로 할당한 배열은 실행 중에라도 realloc으로 크기를 재 할당해 변경할 수 있다.
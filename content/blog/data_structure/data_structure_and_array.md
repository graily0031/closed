---
title: "자료구조 개념과 배열"
date: "2022-02-11T23:56:00.000Z"
template: "blog"
draft: false
slug: "/blog/data_structure_and_array/"
category: "data_structure"
description: ""
---

## 자료구조
### 자료의 정의
`자료`는 현실 세계에 관찰이나 측정을 통해 수집된 `값(value)`이나 `사실(fact)`을 의미한다. 우리 생활에서 실제로 만질 수 있거나 볼 수 있는 것 (즉 길이, 무게, 부피 등을 측정할수 있는 대상)에 대해 물리적인 단위로 표현하여 얻어낼 수 있는 내용들을 의미한다.

### 정보의 정의
어떤 상황에 대해 적절한 의사결정을 할 수 있게 해주는 지식으로써 자료의 유효한 해설이나 자료 상호간의 관계를 표현하는 내용   
어떤 상황에 적절한 경정이나 판단에 사용될 수 있는 처리형태로 가공되거나 분류되기 위해 `처리 과정`을 거쳐서 정의되고 정돈된 `자료`의 2차 처리 결과물을 의미한다.

### 추상화
`공통적인 개념`을 이용해 같은 종류의 `다양한 객체를 정의하는 것`을 의미한다. 추상화를 통해 간결하게 말하는 `사람의 의사`를 전달할 수 있게되는 것

#### 자료의 추상화
> 다양한 객체를 컴퓨터에 표현하고 활용하기 위해 필요한 자료의 구조에 대해 `공통적 특징`만을 뽑아 정의한 것이다.   
> 자료의 추상화에는 컴퓨터 내부의 이진수 표현 방법, 저장 위치 등은 포함되지 않고 단순히 개발자의 머릿속에 그림을 그리는 것 처럼 개념화하는 것이다.

### 자료구조의 개념
추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화한 것   
자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율 적으로 수행되거나 소프트웨어의 확장성에 문제가 생길 수 있다.

#### 자료구조와 알고리즘의 관계
> 자료구조는 `입력 자료에 대한 추상화`된 상태라면 알고리즘은 컴퓨터가 수행해야 할 `명령어의 추상화`
```
    자료구조---------->컴퓨터---------->출력
                        ^
                     알고리즘
```
#### 자료구조와 알고리즘의 추상화 및 구체화
> 입력값을 머릿속에서 추상화된 형태(`자료구조`)로 구조화 하고,   
> 수행되어야 할 명령어를 머릿속에서 추상화된 형태(`알고리즘`)로 체계회 한다.
```
    자료구조---------->컴퓨터---------->출력
                        ^
                     프로그램
                        ^
                     알고리즘
```
### 알고리즘의 개념
컴퓨터에게 일을 시키는 `명령어의 연속된 덩어리`이다.   
컴퓨터에 의해 수행되기 위해 필요한 `명령어의 유한 집합`이 `사람의 머릿속에 추상화`되어 존재하는 것이다.   
사람이 컴퓨터에게 일을 시키기 위해 사람의 의도와 명령을 전달하기 위한 방법이다. (언어 및 글)

#### 알고리즘의 조건
> 출력, 유효성, 입력, 명확성, 유한성

### 알고리즘의 실행시간 분석
알고리즘을 실행하는 데 필요한 `예측 시간을 측정`하여 알고리즘의 성능을 분석한다.

#### 실행 시간의 예측
> 알고리즘의 실행 횟수를 `O(n)`이라고 표현한다.   
> 같은 O(n)을 가진다는 것은 실행 시간이 동일한 것이 아닌 실행 시간의 증가 경향이 유사하다는 의미이다.

### 알고리즘의 성능 분석
컴퓨터와 `실제로 프로그램을 실행하는 데 걸리는 시간을 측정`하여 알고리즘의 성능을 측정한다.

#### 실행 시간의 측정
> 실제로 실행 시간을 시계로 잰다는 것을 의미한다. 실제로 실행될 수 있는 프로그램이 있어야 하며, 시스템 시계를 이용한다.


## 배열
일정한 차례나 간격에 따라 벌여 놓는다. -> 사전적 정의   
`차례 (순서)`와 관련된 기본적인 자료구조이고 인덱스와 원소값 즉 index, value의 쌍으로 구성된 집합을 의미한다.   
`원소의 메모리 공간 (메인 메모리, DDR)의 물리적인 위치를 순서적으로 결정하는 특징을 가지고 있으며, 배열의 순서는 메모리 공간에서 저장되는 원소 값의 물리적 순서를 갖고 있다`   
쉽게 설명하자면 `호수 (index)`로 표현되는 `순서`를 갖는 `아파트(메모리 영역, 원소값을 위한 저장소) 원소`들이 모두 `같은 자료형`과 `같은 크기의 기억 공간`을 가진다.

> 인덱스 값은 추상화된 값이다. 즉 `컴퓨터의 내부구조`나 `메모리 주소와` 무관하게 개발자에게 개념적으로 정의된다.   
> 메모리 주소값은 `실제 메모리의 물리적인 위치값(주소값)`을 의미한다.

### 배열의 추상 자료형

#### 추상 자료형과 자료형
> 추상 자료형 -> 객체 및 관련된 연상의 정의   
> 자료형      -> 메모리 저장 할당을 위한 선언

#### ADT Array 객체
> <i ∈ Index, i ∈ Element> 쌍들의 집합을 의미한다.   
> Index - 순서를 나타내는 원소의 유한집합   
> Element - 타입이 같은 원소의 집합
>> 연산 -> a ∈ Array; a ∈ Index; item ∈ Element; n ∈ Integer인 모든 a, itme, n에 대하여 다음과 같은 연산이 정의된다.   
>> a : 0개 이상의 원소를 갖는 배열   
>> item : 배열에 저장되는 원소   
>> n : 배열의 최대 크기를 정의하는 정수값   
>> Array create(n) ::= 배열의 크기가 n인 빈 배열을 생성하고 배열을 반환한다.   
>> `Element retrieve(a, i) ::= if (i ∈ Index) them { 배열의 i번째에 해당하는 원소값 'e'를 반환한다; } else { 에로 메시지를 반환한다; }   `

``` c++
/* 배열의 생성 */

void create(int*a, int n) {	// n = 5
	int i;
    for(i = 0, i < n; i++) {
    	a[i] = 0;
    }
}

/*      실행 결과
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 0 ]	[ 0 ]	[ 0 ]	[ 0 ]	[ 0 ]	
*/

```

``` c++
// 배열값의 검색 (retrieve 연산)

#define ARRAY_SIZE 5

int retrieve(int *a, int i) {	// i = 2
	
    if(i >= 0 && i < ARRAY_SIZE) {
    	return a[i];
	}
	else {
		printf("Error\n");
    	return (-1);
	}
}

/*      실행 결과
                    -------
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 10 ]	[ 20 ]	[ 30 ]	[ 40 ]	[ 50 ]	
			        -------
                    --->출력
*/

```

``` c++

#define ARRAY_SIZE 5

int store(int *a, int i, int e) {	// i = 2, e = 35
	
    if(i >= 0 && i < ARRAY_SIZE) {
    	a[i] = e;
	}
	else {
		printf("Error\n");
	}
}

/*      실행 결과
                       		-------
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 10 ]	[ 20 ]	[ 30 ]	[ 40 ]	[ 50 ]	
			                -------
                              ▽
                              ▽
                       		-------
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 10 ]	[ 20 ]	[ 30 ]	[ 35 ]	[ 50 ]	
			                -------                  
*/
```

#### 1차원 배열의 정의
> 한 줄 짜리 배열의 의미하며, 하나의 인덱스로 구분된다.
>> `A[i]`는 배열의 첫 번째 원소 `A[0]`이 저장된 주소인 `a`로부터 시작하여, `A[0]부터 A[i - 1]개까지` `i`개의 배열 `A[]`를 지나서 저장된다.   
>> 따라서, `A[]`의 시작주소를 `a`라고 가정하면, `A[i]` 저장 주소는 `[a + i * k]`가 된다.

``` c++
A[0]	A[1]	A[2]	A[3]	A[4]
-------------------------------------
A(L)	A(L+1)	A(L+2)	A(L+3)	A(U)
```

#### 배열의 확장
> 행렬을 컴퓨터에서 표현하기에는 2차원 배열이 적합하다.
``` c++
5	2	6	2
7	2	0	0
0	1	1	9
```

``` c++
Column 열, 세로
row    행, 가로

A[0][0]		A[0][1]		A[0][2]		.......		.......		A[0][m-1]
A[1][0]		.......		.......		.......		.......		.......
A[2][0]		.......		.......		.......		.......		.......
.......		.......		.......		.......		.......		.......
A[n-1][0]	.......		.......		.......		.......		A[n-1][m-1]
```

#### 열 우선 배열
> 1차원 배열을 여러 개 세워 놓은 것이 2차원 배열이다.

``` c++
A[0]		A[1]		A[2]		A[3]		A[4]
 □		      □		      □		      □		      □	        B[0]
 □		      □		      □		      □		      □	        B[1]
 □		      □		      □		      □		      □	        B[2]
```

#### 행 우선 할당
> 가로의 1차원 배열 단위로 메모리 영역을 우선 할당한다.

``` c++
	A[2,3]
    
   	0	1	2
0	●	●	●   ----> ⓐ
1	□	□	□

..................
    ●	[0,0]		   |
    ●	[0,1]	0행	   | ⓐ
    ●	[0,2]		   ↓
  ----------------
    □	[1,0]
    □	[1,1]	1행
    □	[1,2]
 
 /* 행 우선 */
```

#### 열 우선 할당
> 세로의 1차원 배열 단위로 메모리 영역을 우선 할당한다.

``` c++
	A[2,3]    
 
   	0	1	2
0	●	□	▼   
1	●	□	▼

..................
    ●	[0,0]	0행	   |
    ●	[1,0]	0행	   | ⓐ
-------------------
    □	[0,1]	1행	   ↓
    □	[1,1]	1행
-------------------
    ▼	[0,2]	2행
    ▼	[1,2]	2행
 
 /* 열 우선  */
```

#### c언어에서의 2차원 배열 -> 행 우선 순서 저장
> 예를 들어 c언어에서 `A[5][3]`을 선언하면 다음과 같은 배열이 생성된다.

``` c++
/* 배열의 길이 선언 -> A[5][3] */      
----------------- 인덱스 번호 -----------------
//▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
	[0][0]	[0][1]	[0][2]	[0][3]	[0][4]
//▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
//○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○
	[1][0]	[1][1]	[1][2]	[1][3]	[1][4]
//○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○
//▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
	[2][0]	[2][1]	[2][2]	[2][3]	[2][4]
//▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
```

#### 희소 행렬의 개념
> 원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많다.

``` c++
A = [	]
      ↓
-----------------------------------------
|	0	20	0	0	9	0	0	11	0	|
-----------------------------------------
|	0	0	0	0	0	0	0	0	0	|
-----------------------------------------
|	78	0	0	0	0	0	0	0	0	|
-----------------------------------------
|	0	0	0	0	67	0	0	0	0	|
-----------------------------------------
|	0	31	0	0	0	0	0	0	0	|
-----------------------------------------
|	0	0	0	91	0	0	44	0	0	|
-----------------------------------------
|	0	0	0	0	0	0	0	0	0	|
-----------------------------------------
|	0	0	0	0	19	0	0	27	0	|
-----------------------------------------
```

#### 희소 행렬의 일반적인 배열 표현
> 메모리 낭비를 막고 효율성을 높이기 위해 0인 원소는 저장하지 않고 0이 아닌 값만을 따로 모아 저장하는 방법이 필요하다.

``` c++
	|	[0] 	[1] 	[2] 	[3] 	[4] 	[5] 	[6] 	[7] 	[8]	
//	-------------------------------------------------------------------------
[0]	|	0	    20	     0	     0	     9	     0	     0	     11	     0	|
	-------------------------------------------------------------------------
[1]	|	0	     0	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[2]	|	78	     0	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[3]	|	0	     0	     0	     0	     67	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[4]	|	0	     31	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[5]	|	0	     0	     0	     91	     0	     0	     44	     0	     0	|
//	-------------------------------------------------------------------------
[6]	|	0	     0	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[7]	|	0	     0	     0	     0	     19 	 0	     0	     27	     0	|
//	-------------------------------------------------------------------------

```
``` c++

		행		열		값		
	-------------------------
0	|	8	|	9	|	10	|
	-------------------------
1	|	0	|	1	|	20	|
2	|	0	|	4	|	9	|
3	|	0	|	7	|	11	|
4	|	2	|	0	|	78	|
5	|	3	|	4	|	67	|
6	|	4	|	1	|	31	|
7	|	5	|	3	|	91	|
8	|	5	|	6	|	44	|
9	|	7	|	4	|	19	|
10	|	7	|	7	|	27	|
```
{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/data_structure/stack_and_queue/",
    "result": {"data":{"site":{"siteMetadata":{"title":"일기장"}},"markdownRemark":{"id":"102c4889-b8ed-5414-8f5c-f0d4da54955b","excerpt":"스택 (stack) 스택이란 쌓아올린다는 것을 의미하며, 원반 던지기 하듯 차곡차곡 쌓아올린 형태의 자료 구조를 의미한다. 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고 top…","html":"<h2>스택 (stack)</h2>\n<p>스택이란 쌓아올린다는 것을 의미하며, 원반 던지기 하듯 차곡차곡 쌓아올린 형태의 자료 구조를 의미한다.<br>\n같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고 top으로 정한 곳을 통해서만 접근할 수 있다. (쉽게 말해 입구가 하나밖에 없다 생각하면 쉽다.)<br>\ntop에는 가장 최근에 들어온 자료를 가리키고 있고 새 자료를 넣을 때 top이 가리키는 자료의 위에 쌓이게 된다. 삭제할 때 마찬가지로 top을 통해 가장 최근에 넣은 자료 먼저 삭제된다.<br>\ntop을 통해 삽입하는 연산을 <code class=\"language-text\">push</code>, 마찬가지로 top을 통해 삭제하는 연산을 <code class=\"language-text\">pop</code>이라 한다. 이러한 스택의 구조를 <code class=\"language-text\">후입 선출</code> 구조라 하며 줄여서 <code class=\"language-text\">LIFO(last in first out)</code>이라 부른다.<br>\n만일 스택 저장공간에 데이터가 없는데 프로그램이 스택에서 데이터를 꺼내려고 할 경우 <code class=\"language-text\">stack underflow</code> 현상이 일어나게 되며, 반대로 스택 저장공간이 가득찼을 때 하나의 데이터를 더 넣고자 할 경우 <code class=\"language-text\">stack overflow</code> 현상이 일어나게 된다. 이 두 현상은 프로그램에 오류를 야기하게 된다.</p>\n<h3>스택 활용 예</h3>\n<ul>\n<li>웹 브라우저 뒤로가기</li>\n<li>역순 문자열 만들기</li>\n<li>후위 표기법 계산</li>\n<li>실행 취소(undo)…등등</li>\n</ul>\n<h3>스택 예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;stdio.h&gt;\r\n#define MAX_SIZE 5\r\n\r\n\r\nint stack[MAX_SIZE];\r\nint top = 0;\r\n\r\n\r\nvoid push(int val) {\r\n\tif(top &gt;= MAX_SIZE)\r\n\t{\r\n\t\tprintf(&quot;----overflow----&quot;);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstack[top] = val;\r\n\t\ttop ++;\r\n\t}\r\n}\r\n\r\nvoid pop() {\r\n\tif (top == 0)\r\n\t{\r\n\t\tprintf(&quot;----underflow&quot;);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tprintf(&quot;pop_%d\\n&quot;, stack[top - 1]);\r\n\t\tstack[top - 1] = 0;\r\n\t\ttop--;\r\n\t}\r\n}\r\n\r\nvoid show() {\r\n\tint n;\r\n\tprintf(&quot;스택----------\\n&quot;);\r\n\tfor(n = 0; n &lt; MAX_SIZE; n++)printf(&quot;%d\\t&quot;, stack[n]);\r\n\t\r\n\tprintf(&quot;\\n&quot;);\r\n}\r\n\r\nint main() {\r\n\tint act = 0;\r\n\tint data;\r\n\t\r\n\tprintf(&quot;명령어를 입력하세요\\n&quot;);\r\n\tprintf(&quot;1.push\\t 2.pop\\t 3.exit \\n&quot;);\r\n\tscanf(&quot;%d&quot;, &amp;act);\r\n\t\r\n\tswitch(act)\r\n\t{\r\n\t\tcase 1:\r\n\t\t\tprintf(&quot;insert push val : &quot;);\r\n\t\t\tscanf(&quot;%d&quot;, &amp;data);\r\n\t\t\tpush(data);\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tcase 2:\r\n\t\t\tpop();\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase 3:\r\n\t\t\tact = 4;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t}\r\n\tshow();\r\n}</code></pre></div>\n<h2>큐 (queue)</h2>\n<p>큐는 예를 들어 은행의 번호표를 생각하면 쉽다. 창구에선 가장 먼저 번호표를 뽑은 사람의 업무를 처리해주는 것 처럼 선입선출 방식 즉 줄여서 <code class=\"language-text\">FIFO(first in first out)</code>방식의 자료구조이다.<br>\n쉽게 생각해서 큐의 입구는 두개가 있다고 가정하면 된다. 한 쪽 끝에선 삽입 작업을 하고 다른 한 쪽 끝에선 삭제 작업이 이루어 지고 있다.<br>\n삭제 연산만 수행되는 곳을 <code class=\"language-text\">front</code>, 삽입 연산만 수행되는 곳을 <code class=\"language-text\">rear</code>로 정해 각각의 연산작업만 수행된다.<br>\n<code class=\"language-text\">rear</code>에서 이루어지는 삽입연산을 <code class=\"language-text\">enQueue</code>, <code class=\"language-text\">front</code>에서 이루어지는 삭제연산을 <code class=\"language-text\">deQueue</code>라 부른다.<br>\n접근 방법은 위에 설명했다 시피 가장 첫 원소와 끝 원소로만 가능하다. 즉 <code class=\"language-text\">front</code>에서는 가장 먼저 큐에 들어온 <code class=\"language-text\">첫 번째 원소</code>가 되며, <code class=\"language-text\">rear</code>에서는 가장 늦게 큐에 들어온 <code class=\"language-text\">마지막 원소</code>가 되는 것 이다.</p>\n<h3>큐 활용 예</h3>\n<ul>\n<li>은행 업무</li>\n<li>프로세스 관리</li>\n<li>너비 우선 탐색(BFS / breadth first search) 구현</li>\n<li>캐시(cache) 구현</li>\n<li>우선순위가 같은 작업의 예약 구현</li>\n</ul>\n<h3>큐 예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include &lt;stdio.h&gt;\r\n#define MAX_SIZE 5\r\n\r\n\r\nint queue[MAX_SIZE];\r\nint front = -1;\r\nint rear = -1;\r\n\r\n\r\n\r\nint isEmpty(void) {\r\n\tif (front == rear)\r\n\t{\r\n\t\treturn true;\t\r\n\t } \r\n\telse\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nvoid push(int val) {\r\n\tif ((rear + 1) % MAX_SIZE == front)\r\n\t{\r\n\t\tprintf(&quot;----isFull----\\n&quot;);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tqueue[++rear] = val;\r\n\t}\r\n}\r\n\r\nint pop() {\r\n\tif(isEmpty())\r\n\t{\r\n\t\tprintf(&quot;----isEmpty---\\n&quot;);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfront = (front + 1) % MAX_SIZE;\r\n\t\treturn queue[front];\r\n\t}\r\n}\r\n\r\n\r\nint main() {\r\n\tint act = 0;\r\n\tint data;\r\n\t\r\n\tprintf(&quot;명령어를 입력하세요\\n&quot;);\r\n\tprintf(&quot;1.push\\t 2.pop\\t 3.exit \\n&quot;);\r\n\tscanf(&quot;%d&quot;, &amp;act);\r\n\t\r\n\tswitch(act)\r\n\t{\r\n\t\tcase 1:\r\n\t\t\tprintf(&quot;insert push val : &quot;);\r\n\t\t\tscanf(&quot;%d&quot;, &amp;data);\r\n\t\t\tpush(data);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tprintf(&quot;pop()-----&gt;&quot;);\r\n\t\t\tprintf(&quot;%d\\n&quot;, pop());\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase 3:\r\n\t\t\tact = 4;\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t}\r\n}</code></pre></div>","frontmatter":{"title":"스택(stack) & 큐(queue)","date":"February 12, 2022","description":""}},"previous":{"fields":{"slug":"/data_structure/data_structure_and_array/"},"frontmatter":{"title":"자료구조 개념과 배열"}},"next":{"fields":{"slug":"/etc/hugo_tutorial/"},"frontmatter":{"title":"github 블로그 만들기 (with hugo)"}}},"pageContext":{"id":"102c4889-b8ed-5414-8f5c-f0d4da54955b","previousPostId":"40d079dd-76e5-51ee-aa73-a49ccfa26d47","nextPostId":"6fcda7be-0c4e-5d02-90b1-89f8329ffc79"}},
    "staticQueryHashes": ["3257411868","642825376"]}
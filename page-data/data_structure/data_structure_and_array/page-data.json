{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/data_structure/data_structure_and_array/",
    "result": {"data":{"site":{"siteMetadata":{"title":"일기장"}},"markdownRemark":{"id":"40d079dd-76e5-51ee-aa73-a49ccfa26d47","excerpt":"…","html":"<h2>자료구조</h2>\n<h3>자료의 정의</h3>\n<p><code class=\"language-text\">자료</code>는 현실 세계에 관찰이나 측정을 통해 수집된 <code class=\"language-text\">값(value)</code>이나 <code class=\"language-text\">사실(fact)</code>을 의미한다. 우리 생활에서 실제로 만질 수 있거나 볼 수 있는 것 (즉 길이, 무게, 부피 등을 측정할수 있는 대상)에 대해 물리적인 단위로 표현하여 얻어낼 수 있는 내용들을 의미한다.</p>\n<h3>정보의 정의</h3>\n<p>어떤 상황에 대해 적절한 의사결정을 할 수 있게 해주는 지식으로써 자료의 유효한 해설이나 자료 상호간의 관계를 표현하는 내용<br>\n어떤 상황에 적절한 경정이나 판단에 사용될 수 있는 처리형태로 가공되거나 분류되기 위해 <code class=\"language-text\">처리 과정</code>을 거쳐서 정의되고 정돈된 <code class=\"language-text\">자료</code>의 2차 처리 결과물을 의미한다.</p>\n<h3>추상화</h3>\n<p><code class=\"language-text\">공통적인 개념</code>을 이용해 같은 종류의 <code class=\"language-text\">다양한 객체를 정의하는 것</code>을 의미한다. 추상화를 통해 간결하게 말하는 <code class=\"language-text\">사람의 의사</code>를 전달할 수 있게되는 것</p>\n<h4>자료의 추상화</h4>\n<blockquote>\n<p>다양한 객체를 컴퓨터에 표현하고 활용하기 위해 필요한 자료의 구조에 대해 <code class=\"language-text\">공통적 특징</code>만을 뽑아 정의한 것이다.<br>\n자료의 추상화에는 컴퓨터 내부의 이진수 표현 방법, 저장 위치 등은 포함되지 않고 단순히 개발자의 머릿속에 그림을 그리는 것 처럼 개념화하는 것이다.</p>\n</blockquote>\n<h3>자료구조의 개념</h3>\n<p>추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화한 것<br>\n자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율 적으로 수행되거나 소프트웨어의 확장성에 문제가 생길 수 있다.</p>\n<h4>자료구조와 알고리즘의 관계</h4>\n<blockquote>\n<p>자료구조는 <code class=\"language-text\">입력 자료에 대한 추상화</code>된 상태라면 알고리즘은 컴퓨터가 수행해야 할 <code class=\"language-text\">명령어의 추상화</code></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    자료구조---------->컴퓨터---------->출력\r\n                        ^\r\n                     알고리즘</code></pre></div>\n<h4>자료구조와 알고리즘의 추상화 및 구체화</h4>\n<blockquote>\n<p>입력값을 머릿속에서 추상화된 형태(<code class=\"language-text\">자료구조</code>)로 구조화 하고,<br>\n수행되어야 할 명령어를 머릿속에서 추상화된 형태(<code class=\"language-text\">알고리즘</code>)로 체계회 한다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    자료구조---------->컴퓨터---------->출력\r\n                        ^\r\n                     프로그램\r\n                        ^\r\n                     알고리즘</code></pre></div>\n<h3>알고리즘의 개념</h3>\n<p>컴퓨터에게 일을 시키는 <code class=\"language-text\">명령어의 연속된 덩어리</code>이다.<br>\n컴퓨터에 의해 수행되기 위해 필요한 <code class=\"language-text\">명령어의 유한 집합</code>이 <code class=\"language-text\">사람의 머릿속에 추상화</code>되어 존재하는 것이다.<br>\n사람이 컴퓨터에게 일을 시키기 위해 사람의 의도와 명령을 전달하기 위한 방법이다. (언어 및 글)</p>\n<h4>알고리즘의 조건</h4>\n<blockquote>\n<p>출력, 유효성, 입력, 명확성, 유한성</p>\n</blockquote>\n<h3>알고리즘의 실행시간 분석</h3>\n<p>알고리즘을 실행하는 데 필요한 <code class=\"language-text\">예측 시간을 측정</code>하여 알고리즘의 성능을 분석한다.</p>\n<h4>실행 시간의 예측</h4>\n<blockquote>\n<p>알고리즘의 실행 횟수를 <code class=\"language-text\">O(n)</code>이라고 표현한다.<br>\n같은 O(n)을 가진다는 것은 실행 시간이 동일한 것이 아닌 실행 시간의 증가 경향이 유사하다는 의미이다.</p>\n</blockquote>\n<h3>알고리즘의 성능 분석</h3>\n<p>컴퓨터와 <code class=\"language-text\">실제로 프로그램을 실행하는 데 걸리는 시간을 측정</code>하여 알고리즘의 성능을 측정한다.</p>\n<h4>실행 시간의 측정</h4>\n<blockquote>\n<p>실제로 실행 시간을 시계로 잰다는 것을 의미한다. 실제로 실행될 수 있는 프로그램이 있어야 하며, 시스템 시계를 이용한다.</p>\n</blockquote>\n<h2>배열</h2>\n<p>일정한 차례나 간격에 따라 벌여 놓는다. -> 사전적 정의<br>\n<code class=\"language-text\">차례 (순서)</code>와 관련된 기본적인 자료구조이고 인덱스와 원소값 즉 index, value의 쌍으로 구성된 집합을 의미한다.<br>\n<code class=\"language-text\">원소의 메모리 공간 (메인 메모리, DDR)의 물리적인 위치를 순서적으로 결정하는 특징을 가지고 있으며, 배열의 순서는 메모리 공간에서 저장되는 원소 값의 물리적 순서를 갖고 있다</code><br>\n쉽게 설명하자면 <code class=\"language-text\">호수 (index)</code>로 표현되는 <code class=\"language-text\">순서</code>를 갖는 <code class=\"language-text\">아파트(메모리 영역, 원소값을 위한 저장소) 원소</code>들이 모두 <code class=\"language-text\">같은 자료형</code>과 <code class=\"language-text\">같은 크기의 기억 공간</code>을 가진다.</p>\n<blockquote>\n<p>인덱스 값은 추상화된 값이다. 즉 <code class=\"language-text\">컴퓨터의 내부구조</code>나 <code class=\"language-text\">메모리 주소와</code> 무관하게 개발자에게 개념적으로 정의된다.<br>\n메모리 주소값은 <code class=\"language-text\">실제 메모리의 물리적인 위치값(주소값)</code>을 의미한다.</p>\n</blockquote>\n<h3>배열의 추상 자료형</h3>\n<h4>추상 자료형과 자료형</h4>\n<blockquote>\n<p>추상 자료형 -> 객체 및 관련된 연상의 정의<br>\n자료형      -> 메모리 저장 할당을 위한 선언</p>\n</blockquote>\n<h4>ADT Array 객체</h4>\n<blockquote>\n<p>&#x3C;i ∈ Index, i ∈ Element> 쌍들의 집합을 의미한다.<br>\nIndex - 순서를 나타내는 원소의 유한집합<br>\nElement - 타입이 같은 원소의 집합</p>\n<blockquote>\n<p>연산 -> a ∈ Array; a ∈ Index; item ∈ Element; n ∈ Integer인 모든 a, itme, n에 대하여 다음과 같은 연산이 정의된다.<br>\na : 0개 이상의 원소를 갖는 배열<br>\nitem : 배열에 저장되는 원소<br>\nn : 배열의 최대 크기를 정의하는 정수값<br>\nArray create(n) ::= 배열의 크기가 n인 빈 배열을 생성하고 배열을 반환한다.<br>\n<code class=\"language-text\">Element retrieve(a, i) ::= if (i ∈ Index) them { 배열의 i번째에 해당하는 원소값 'e'를 반환한다; } else { 에로 메시지를 반환한다; }   </code></p>\n</blockquote>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">/* 배열의 생성 */\r\n\r\nvoid create(int*a, int n) {\t// n = 5\r\n\tint i;\r\n    for(i = 0, i &lt; n; i++) {\r\n    \ta[i] = 0;\r\n    }\r\n}\r\n\r\n/*      실행 결과\r\n\ta[0]\ta[1]\ta[2]\ta[3]\ta[4]\r\na\t[ 0 ]\t[ 0 ]\t[ 0 ]\t[ 0 ]\t[ 0 ]\t\r\n*/\r\n</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// 배열값의 검색 (retrieve 연산)\r\n\r\n#define ARRAY_SIZE 5\r\n\r\nint retrieve(int *a, int i) {\t// i = 2\r\n\t\r\n    if(i &gt;= 0 &amp;&amp; i &lt; ARRAY_SIZE) {\r\n    \treturn a[i];\r\n\t}\r\n\telse {\r\n\t\tprintf(&quot;Error\\n&quot;);\r\n    \treturn (-1);\r\n\t}\r\n}\r\n\r\n/*      실행 결과\r\n                    -------\r\n\ta[0]\ta[1]\ta[2]\ta[3]\ta[4]\r\na\t[ 10 ]\t[ 20 ]\t[ 30 ]\t[ 40 ]\t[ 50 ]\t\r\n\t\t\t        -------\r\n                    ---&gt;출력\r\n*/\r\n</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">\r\n#define ARRAY_SIZE 5\r\n\r\nint store(int *a, int i, int e) {\t// i = 2, e = 35\r\n\t\r\n    if(i &gt;= 0 &amp;&amp; i &lt; ARRAY_SIZE) {\r\n    \ta[i] = e;\r\n\t}\r\n\telse {\r\n\t\tprintf(&quot;Error\\n&quot;);\r\n\t}\r\n}\r\n\r\n/*      실행 결과\r\n                       \t\t-------\r\n\ta[0]\ta[1]\ta[2]\ta[3]\ta[4]\r\na\t[ 10 ]\t[ 20 ]\t[ 30 ]\t[ 40 ]\t[ 50 ]\t\r\n\t\t\t                -------\r\n                              ▽\r\n                              ▽\r\n                       \t\t-------\r\n\ta[0]\ta[1]\ta[2]\ta[3]\ta[4]\r\na\t[ 10 ]\t[ 20 ]\t[ 30 ]\t[ 35 ]\t[ 50 ]\t\r\n\t\t\t                -------                  \r\n*/</code></pre></div>\n<h4>1차원 배열의 정의</h4>\n<blockquote>\n<p>한 줄 짜리 배열의 의미하며, 하나의 인덱스로 구분된다.</p>\n<blockquote>\n<p><code class=\"language-text\">A[i]</code>는 배열의 첫 번째 원소 <code class=\"language-text\">A[0]</code>이 저장된 주소인 <code class=\"language-text\">a</code>로부터 시작하여, <code class=\"language-text\">A[0]부터 A[i - 1]개까지</code> <code class=\"language-text\">i</code>개의 배열 <code class=\"language-text\">A[]</code>를 지나서 저장된다.<br>\n따라서, <code class=\"language-text\">A[]</code>의 시작주소를 <code class=\"language-text\">a</code>라고 가정하면, <code class=\"language-text\">A[i]</code> 저장 주소는 <code class=\"language-text\">[a + i * k]</code>가 된다.</p>\n</blockquote>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">A[0]\tA[1]\tA[2]\tA[3]\tA[4]\r\n-------------------------------------\r\nA(L)\tA(L+1)\tA(L+2)\tA(L+3)\tA(U)</code></pre></div>\n<h4>배열의 확장</h4>\n<blockquote>\n<p>행렬을 컴퓨터에서 표현하기에는 2차원 배열이 적합하다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">5\t2\t6\t2\r\n7\t2\t0\t0\r\n0\t1\t1\t9</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">Column 열, 세로\r\nrow    행, 가로\r\n\r\nA[0][0]\t\tA[0][1]\t\tA[0][2]\t\t.......\t\t.......\t\tA[0][m-1]\r\nA[1][0]\t\t.......\t\t.......\t\t.......\t\t.......\t\t.......\r\nA[2][0]\t\t.......\t\t.......\t\t.......\t\t.......\t\t.......\r\n.......\t\t.......\t\t.......\t\t.......\t\t.......\t\t.......\r\nA[n-1][0]\t.......\t\t.......\t\t.......\t\t.......\t\tA[n-1][m-1]</code></pre></div>\n<h4>열 우선 배열</h4>\n<blockquote>\n<p>1차원 배열을 여러 개 세워 놓은 것이 2차원 배열이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">A[0]\t\tA[1]\t\tA[2]\t\tA[3]\t\tA[4]\r\n □\t\t      □\t\t      □\t\t      □\t\t      □\t        B[0]\r\n □\t\t      □\t\t      □\t\t      □\t\t      □\t        B[1]\r\n □\t\t      □\t\t      □\t\t      □\t\t      □\t        B[2]</code></pre></div>\n<h4>행 우선 할당</h4>\n<blockquote>\n<p>가로의 1차원 배열 단위로 메모리 영역을 우선 할당한다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">\tA[2,3]\r\n    \r\n   \t0\t1\t2\r\n0\t●\t●\t●   ----&gt; ⓐ\r\n1\t□\t□\t□\r\n\r\n..................\r\n    ●\t[0,0]\t\t   |\r\n    ●\t[0,1]\t0행\t   | ⓐ\r\n    ●\t[0,2]\t\t   ↓\r\n  ----------------\r\n    □\t[1,0]\r\n    □\t[1,1]\t1행\r\n    □\t[1,2]\r\n \r\n /* 행 우선 */</code></pre></div>\n<h4>열 우선 할당</h4>\n<blockquote>\n<p>세로의 1차원 배열 단위로 메모리 영역을 우선 할당한다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">\tA[2,3]    \r\n \r\n   \t0\t1\t2\r\n0\t●\t□\t▼   \r\n1\t●\t□\t▼\r\n\r\n..................\r\n    ●\t[0,0]\t0행\t   |\r\n    ●\t[1,0]\t0행\t   | ⓐ\r\n-------------------\r\n    □\t[0,1]\t1행\t   ↓\r\n    □\t[1,1]\t1행\r\n-------------------\r\n    ▼\t[0,2]\t2행\r\n    ▼\t[1,2]\t2행\r\n \r\n /* 열 우선  */</code></pre></div>\n<h4>c언어에서의 2차원 배열 -> 행 우선 순서 저장</h4>\n<blockquote>\n<p>예를 들어 c언어에서 <code class=\"language-text\">A[5][3]</code>을 선언하면 다음과 같은 배열이 생성된다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">/* 배열의 길이 선언 -&gt; A[5][3] */      \r\n----------------- 인덱스 번호 -----------------\r\n//▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼\r\n\t[0][0]\t[0][1]\t[0][2]\t[0][3]\t[0][4]\r\n//▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲\r\n//○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○\r\n\t[1][0]\t[1][1]\t[1][2]\t[1][3]\t[1][4]\r\n//○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○\r\n//▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼\r\n\t[2][0]\t[2][1]\t[2][2]\t[2][3]\t[2][4]\r\n//▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲</code></pre></div>\n<h4>희소 행렬의 개념</h4>\n<blockquote>\n<p>원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">A = [\t]\r\n      ↓\r\n-----------------------------------------\r\n|\t0\t20\t0\t0\t9\t0\t0\t11\t0\t|\r\n-----------------------------------------\r\n|\t0\t0\t0\t0\t0\t0\t0\t0\t0\t|\r\n-----------------------------------------\r\n|\t78\t0\t0\t0\t0\t0\t0\t0\t0\t|\r\n-----------------------------------------\r\n|\t0\t0\t0\t0\t67\t0\t0\t0\t0\t|\r\n-----------------------------------------\r\n|\t0\t31\t0\t0\t0\t0\t0\t0\t0\t|\r\n-----------------------------------------\r\n|\t0\t0\t0\t91\t0\t0\t44\t0\t0\t|\r\n-----------------------------------------\r\n|\t0\t0\t0\t0\t0\t0\t0\t0\t0\t|\r\n-----------------------------------------\r\n|\t0\t0\t0\t0\t19\t0\t0\t27\t0\t|\r\n-----------------------------------------</code></pre></div>\n<h4>희소 행렬의 일반적인 배열 표현</h4>\n<blockquote>\n<p>메모리 낭비를 막고 효율성을 높이기 위해 0인 원소는 저장하지 않고 0이 아닌 값만을 따로 모아 저장하는 방법이 필요하다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">\t|\t[0] \t[1] \t[2] \t[3] \t[4] \t[5] \t[6] \t[7] \t[8]\t\r\n//\t-------------------------------------------------------------------------\r\n[0]\t|\t0\t    20\t     0\t     0\t     9\t     0\t     0\t     11\t     0\t|\r\n\t-------------------------------------------------------------------------\r\n[1]\t|\t0\t     0\t     0\t     0\t     0\t     0\t     0\t     0\t     0\t|\r\n//\t-------------------------------------------------------------------------\r\n[2]\t|\t78\t     0\t     0\t     0\t     0\t     0\t     0\t     0\t     0\t|\r\n//\t-------------------------------------------------------------------------\r\n[3]\t|\t0\t     0\t     0\t     0\t     67\t     0\t     0\t     0\t     0\t|\r\n//\t-------------------------------------------------------------------------\r\n[4]\t|\t0\t     31\t     0\t     0\t     0\t     0\t     0\t     0\t     0\t|\r\n//\t-------------------------------------------------------------------------\r\n[5]\t|\t0\t     0\t     0\t     91\t     0\t     0\t     44\t     0\t     0\t|\r\n//\t-------------------------------------------------------------------------\r\n[6]\t|\t0\t     0\t     0\t     0\t     0\t     0\t     0\t     0\t     0\t|\r\n//\t-------------------------------------------------------------------------\r\n[7]\t|\t0\t     0\t     0\t     0\t     19 \t 0\t     0\t     27\t     0\t|\r\n//\t-------------------------------------------------------------------------\r\n</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">\r\n\t\t행\t\t열\t\t값\t\t\r\n\t-------------------------\r\n0\t|\t8\t|\t9\t|\t10\t|\r\n\t-------------------------\r\n1\t|\t0\t|\t1\t|\t20\t|\r\n2\t|\t0\t|\t4\t|\t9\t|\r\n3\t|\t0\t|\t7\t|\t11\t|\r\n4\t|\t2\t|\t0\t|\t78\t|\r\n5\t|\t3\t|\t4\t|\t67\t|\r\n6\t|\t4\t|\t1\t|\t31\t|\r\n7\t|\t5\t|\t3\t|\t91\t|\r\n8\t|\t5\t|\t6\t|\t44\t|\r\n9\t|\t7\t|\t4\t|\t19\t|\r\n10\t|\t7\t|\t7\t|\t27\t|</code></pre></div>","frontmatter":{"title":"자료구조 개념과 배열","date":"February 11, 2022","description":""}},"previous":{"fields":{"slug":"/sql/join/"},"frontmatter":{"title":"SQL 개념 익히기 - JOIN"}},"next":{"fields":{"slug":"/data_structure/stack_and_queue/"},"frontmatter":{"title":"스택(stack) & 큐(queue)"}}},"pageContext":{"id":"40d079dd-76e5-51ee-aa73-a49ccfa26d47","previousPostId":"bcac9e0a-2aba-512a-8e9f-9952c5a608d3","nextPostId":"102c4889-b8ed-5414-8f5c-f0d4da54955b"}},
    "staticQueryHashes": ["3257411868","642825376"]}
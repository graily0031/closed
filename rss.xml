<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[Gatsby Starter Blog RSS Feed]]></description><link>https://graily0031.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 11 Feb 2022 15:03:44 GMT</lastBuildDate><item><title><![CDATA[자료구조 개념과 배열]]></title><description><![CDATA[…]]></description><link>https://graily0031.github.io/data_structure/data_structure_and_array/</link><guid isPermaLink="false">https://graily0031.github.io/data_structure/data_structure_and_array/</guid><pubDate>Sat, 12 Feb 2022 23:56:00 GMT</pubDate><content:encoded>&lt;h2&gt;자료구조&lt;/h2&gt;
&lt;h3&gt;자료의 정의&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;자료&lt;/code&gt;는 현실 세계에 관찰이나 측정을 통해 수집된 &lt;code class=&quot;language-text&quot;&gt;값(value)&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;사실(fact)&lt;/code&gt;을 의미한다. 우리 생활에서 실제로 만질 수 있거나 볼 수 있는 것 (즉 길이, 무게, 부피 등을 측정할수 있는 대상)에 대해 물리적인 단위로 표현하여 얻어낼 수 있는 내용들을 의미한다.&lt;/p&gt;
&lt;h3&gt;정보의 정의&lt;/h3&gt;
&lt;p&gt;어떤 상황에 대해 적절한 의사결정을 할 수 있게 해주는 지식으로써 자료의 유효한 해설이나 자료 상호간의 관계를 표현하는 내용&lt;br&gt;
어떤 상황에 적절한 경정이나 판단에 사용될 수 있는 처리형태로 가공되거나 분류되기 위해 &lt;code class=&quot;language-text&quot;&gt;처리 과정&lt;/code&gt;을 거쳐서 정의되고 정돈된 &lt;code class=&quot;language-text&quot;&gt;자료&lt;/code&gt;의 2차 처리 결과물을 의미한다.&lt;/p&gt;
&lt;h3&gt;추상화&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;공통적인 개념&lt;/code&gt;을 이용해 같은 종류의 &lt;code class=&quot;language-text&quot;&gt;다양한 객체를 정의하는 것&lt;/code&gt;을 의미한다. 추상화를 통해 간결하게 말하는 &lt;code class=&quot;language-text&quot;&gt;사람의 의사&lt;/code&gt;를 전달할 수 있게되는 것&lt;/p&gt;
&lt;h4&gt;자료의 추상화&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;다양한 객체를 컴퓨터에 표현하고 활용하기 위해 필요한 자료의 구조에 대해 &lt;code class=&quot;language-text&quot;&gt;공통적 특징&lt;/code&gt;만을 뽑아 정의한 것이다.&lt;br&gt;
자료의 추상화에는 컴퓨터 내부의 이진수 표현 방법, 저장 위치 등은 포함되지 않고 단순히 개발자의 머릿속에 그림을 그리는 것 처럼 개념화하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;자료구조의 개념&lt;/h3&gt;
&lt;p&gt;추상화를 통해 알고리즘에서 사용할 자료의 논리적 관계를 구조화한 것&lt;br&gt;
자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율 적으로 수행되거나 소프트웨어의 확장성에 문제가 생길 수 있다.&lt;/p&gt;
&lt;h4&gt;자료구조와 알고리즘의 관계&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;자료구조는 &lt;code class=&quot;language-text&quot;&gt;입력 자료에 대한 추상화&lt;/code&gt;된 상태라면 알고리즘은 컴퓨터가 수행해야 할 &lt;code class=&quot;language-text&quot;&gt;명령어의 추상화&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    자료구조----------&gt;컴퓨터----------&gt;출력
                        ^
                     알고리즘&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;자료구조와 알고리즘의 추상화 및 구체화&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;입력값을 머릿속에서 추상화된 형태(&lt;code class=&quot;language-text&quot;&gt;자료구조&lt;/code&gt;)로 구조화 하고,&lt;br&gt;
수행되어야 할 명령어를 머릿속에서 추상화된 형태(&lt;code class=&quot;language-text&quot;&gt;알고리즘&lt;/code&gt;)로 체계회 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    자료구조----------&gt;컴퓨터----------&gt;출력
                        ^
                     프로그램
                        ^
                     알고리즘&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;알고리즘의 개념&lt;/h3&gt;
&lt;p&gt;컴퓨터에게 일을 시키는 &lt;code class=&quot;language-text&quot;&gt;명령어의 연속된 덩어리&lt;/code&gt;이다.&lt;br&gt;
컴퓨터에 의해 수행되기 위해 필요한 &lt;code class=&quot;language-text&quot;&gt;명령어의 유한 집합&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;사람의 머릿속에 추상화&lt;/code&gt;되어 존재하는 것이다.&lt;br&gt;
사람이 컴퓨터에게 일을 시키기 위해 사람의 의도와 명령을 전달하기 위한 방법이다. (언어 및 글)&lt;/p&gt;
&lt;h4&gt;알고리즘의 조건&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;출력, 유효성, 입력, 명확성, 유한성&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;알고리즘의 실행시간 분석&lt;/h3&gt;
&lt;p&gt;알고리즘을 실행하는 데 필요한 &lt;code class=&quot;language-text&quot;&gt;예측 시간을 측정&lt;/code&gt;하여 알고리즘의 성능을 분석한다.&lt;/p&gt;
&lt;h4&gt;실행 시간의 예측&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;알고리즘의 실행 횟수를 &lt;code class=&quot;language-text&quot;&gt;O(n)&lt;/code&gt;이라고 표현한다.&lt;br&gt;
같은 O(n)을 가진다는 것은 실행 시간이 동일한 것이 아닌 실행 시간의 증가 경향이 유사하다는 의미이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;알고리즘의 성능 분석&lt;/h3&gt;
&lt;p&gt;컴퓨터와 &lt;code class=&quot;language-text&quot;&gt;실제로 프로그램을 실행하는 데 걸리는 시간을 측정&lt;/code&gt;하여 알고리즘의 성능을 측정한다.&lt;/p&gt;
&lt;h4&gt;실행 시간의 측정&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;실제로 실행 시간을 시계로 잰다는 것을 의미한다. 실제로 실행될 수 있는 프로그램이 있어야 하며, 시스템 시계를 이용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;배열&lt;/h2&gt;
&lt;p&gt;일정한 차례나 간격에 따라 벌여 놓는다. -&gt; 사전적 정의&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;차례 (순서)&lt;/code&gt;와 관련된 기본적인 자료구조이고 인덱스와 원소값 즉 index, value의 쌍으로 구성된 집합을 의미한다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;원소의 메모리 공간 (메인 메모리, DDR)의 물리적인 위치를 순서적으로 결정하는 특징을 가지고 있으며, 배열의 순서는 메모리 공간에서 저장되는 원소 값의 물리적 순서를 갖고 있다&lt;/code&gt;&lt;br&gt;
쉽게 설명하자면 &lt;code class=&quot;language-text&quot;&gt;호수 (index)&lt;/code&gt;로 표현되는 &lt;code class=&quot;language-text&quot;&gt;순서&lt;/code&gt;를 갖는 &lt;code class=&quot;language-text&quot;&gt;아파트(메모리 영역, 원소값을 위한 저장소) 원소&lt;/code&gt;들이 모두 &lt;code class=&quot;language-text&quot;&gt;같은 자료형&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;같은 크기의 기억 공간&lt;/code&gt;을 가진다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;인덱스 값은 추상화된 값이다. 즉 &lt;code class=&quot;language-text&quot;&gt;컴퓨터의 내부구조&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;메모리 주소와&lt;/code&gt; 무관하게 개발자에게 개념적으로 정의된다.&lt;br&gt;
메모리 주소값은 &lt;code class=&quot;language-text&quot;&gt;실제 메모리의 물리적인 위치값(주소값)&lt;/code&gt;을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;배열의 추상 자료형&lt;/h3&gt;
&lt;h4&gt;추상 자료형과 자료형&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;추상 자료형 -&gt; 객체 및 관련된 연상의 정의&lt;br&gt;
자료형      -&gt; 메모리 저장 할당을 위한 선언&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;ADT Array 객체&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;#x3C;i ∈ Index, i ∈ Element&gt; 쌍들의 집합을 의미한다.&lt;br&gt;
Index - 순서를 나타내는 원소의 유한집합&lt;br&gt;
Element - 타입이 같은 원소의 집합&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;연산 -&gt; a ∈ Array; a ∈ Index; item ∈ Element; n ∈ Integer인 모든 a, itme, n에 대하여 다음과 같은 연산이 정의된다.&lt;br&gt;
a : 0개 이상의 원소를 갖는 배열&lt;br&gt;
item : 배열에 저장되는 원소&lt;br&gt;
n : 배열의 최대 크기를 정의하는 정수값&lt;br&gt;
Array create(n) ::= 배열의 크기가 n인 빈 배열을 생성하고 배열을 반환한다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;Element retrieve(a, i) ::= if (i ∈ Index) them { 배열의 i번째에 해당하는 원소값 &apos;e&apos;를 반환한다; } else { 에로 메시지를 반환한다; }   &lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;/* 배열의 생성 */

void create(int*a, int n) {	// n = 5
	int i;
    for(i = 0, i &amp;lt; n; i++) {
    	a[i] = 0;
    }
}

/*      실행 결과
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 0 ]	[ 0 ]	[ 0 ]	[ 0 ]	[ 0 ]	
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;// 배열값의 검색 (retrieve 연산)

#define ARRAY_SIZE 5

int retrieve(int *a, int i) {	// i = 2
	
    if(i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; ARRAY_SIZE) {
    	return a[i];
	}
	else {
		printf(&amp;quot;Error\n&amp;quot;);
    	return (-1);
	}
}

/*      실행 결과
                    -------
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 10 ]	[ 20 ]	[ 30 ]	[ 40 ]	[ 50 ]	
			        -------
                    ---&amp;gt;출력
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;
#define ARRAY_SIZE 5

int store(int *a, int i, int e) {	// i = 2, e = 35
	
    if(i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; ARRAY_SIZE) {
    	a[i] = e;
	}
	else {
		printf(&amp;quot;Error\n&amp;quot;);
	}
}

/*      실행 결과
                       		-------
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 10 ]	[ 20 ]	[ 30 ]	[ 40 ]	[ 50 ]	
			                -------
                              ▽
                              ▽
                       		-------
	a[0]	a[1]	a[2]	a[3]	a[4]
a	[ 10 ]	[ 20 ]	[ 30 ]	[ 35 ]	[ 50 ]	
			                -------                  
*/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1차원 배열의 정의&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;한 줄 짜리 배열의 의미하며, 하나의 인덱스로 구분된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;A[i]&lt;/code&gt;는 배열의 첫 번째 원소 &lt;code class=&quot;language-text&quot;&gt;A[0]&lt;/code&gt;이 저장된 주소인 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt;로부터 시작하여, &lt;code class=&quot;language-text&quot;&gt;A[0]부터 A[i - 1]개까지&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;개의 배열 &lt;code class=&quot;language-text&quot;&gt;A[]&lt;/code&gt;를 지나서 저장된다.&lt;br&gt;
따라서, &lt;code class=&quot;language-text&quot;&gt;A[]&lt;/code&gt;의 시작주소를 &lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt;라고 가정하면, &lt;code class=&quot;language-text&quot;&gt;A[i]&lt;/code&gt; 저장 주소는 &lt;code class=&quot;language-text&quot;&gt;[a + i * k]&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;A[0]	A[1]	A[2]	A[3]	A[4]
-------------------------------------
A(L)	A(L+1)	A(L+2)	A(L+3)	A(U)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;배열의 확장&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;행렬을 컴퓨터에서 표현하기에는 2차원 배열이 적합하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;5	2	6	2
7	2	0	0
0	1	1	9&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;Column 열, 세로
row    행, 가로

A[0][0]		A[0][1]		A[0][2]		.......		.......		A[0][m-1]
A[1][0]		.......		.......		.......		.......		.......
A[2][0]		.......		.......		.......		.......		.......
.......		.......		.......		.......		.......		.......
A[n-1][0]	.......		.......		.......		.......		A[n-1][m-1]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;열 우선 배열&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;1차원 배열을 여러 개 세워 놓은 것이 2차원 배열이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;A[0]		A[1]		A[2]		A[3]		A[4]
 □		      □		      □		      □		      □	        B[0]
 □		      □		      □		      □		      □	        B[1]
 □		      □		      □		      □		      □	        B[2]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;행 우선 할당&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;가로의 1차원 배열 단위로 메모리 영역을 우선 할당한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;	A[2,3]
    
   	0	1	2
0	●	●	●   ----&amp;gt; ⓐ
1	□	□	□

..................
    ●	[0,0]		   |
    ●	[0,1]	0행	   | ⓐ
    ●	[0,2]		   ↓
  ----------------
    □	[1,0]
    □	[1,1]	1행
    □	[1,2]
 
 /* 행 우선 */&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;열 우선 할당&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;세로의 1차원 배열 단위로 메모리 영역을 우선 할당한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;	A[2,3]    
 
   	0	1	2
0	●	□	▼   
1	●	□	▼

..................
    ●	[0,0]	0행	   |
    ●	[1,0]	0행	   | ⓐ
-------------------
    □	[0,1]	1행	   ↓
    □	[1,1]	1행
-------------------
    ▼	[0,2]	2행
    ▼	[1,2]	2행
 
 /* 열 우선  */&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;c언어에서의 2차원 배열 -&gt; 행 우선 순서 저장&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어 c언어에서 &lt;code class=&quot;language-text&quot;&gt;A[5][3]&lt;/code&gt;을 선언하면 다음과 같은 배열이 생성된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;/* 배열의 길이 선언 -&amp;gt; A[5][3] */      
----------------- 인덱스 번호 -----------------
//▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
	[0][0]	[0][1]	[0][2]	[0][3]	[0][4]
//▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
//○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○
	[1][0]	[1][1]	[1][2]	[1][3]	[1][4]
//○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○○
//▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
	[2][0]	[2][1]	[2][2]	[2][3]	[2][4]
//▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;희소 행렬의 개념&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;A = [	]
      ↓
-----------------------------------------
|	0	20	0	0	9	0	0	11	0	|
-----------------------------------------
|	0	0	0	0	0	0	0	0	0	|
-----------------------------------------
|	78	0	0	0	0	0	0	0	0	|
-----------------------------------------
|	0	0	0	0	67	0	0	0	0	|
-----------------------------------------
|	0	31	0	0	0	0	0	0	0	|
-----------------------------------------
|	0	0	0	91	0	0	44	0	0	|
-----------------------------------------
|	0	0	0	0	0	0	0	0	0	|
-----------------------------------------
|	0	0	0	0	19	0	0	27	0	|
-----------------------------------------&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;희소 행렬의 일반적인 배열 표현&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;메모리 낭비를 막고 효율성을 높이기 위해 0인 원소는 저장하지 않고 0이 아닌 값만을 따로 모아 저장하는 방법이 필요하다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;	|	[0] 	[1] 	[2] 	[3] 	[4] 	[5] 	[6] 	[7] 	[8]	
//	-------------------------------------------------------------------------
[0]	|	0	    20	     0	     0	     9	     0	     0	     11	     0	|
	-------------------------------------------------------------------------
[1]	|	0	     0	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[2]	|	78	     0	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[3]	|	0	     0	     0	     0	     67	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[4]	|	0	     31	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[5]	|	0	     0	     0	     91	     0	     0	     44	     0	     0	|
//	-------------------------------------------------------------------------
[6]	|	0	     0	     0	     0	     0	     0	     0	     0	     0	|
//	-------------------------------------------------------------------------
[7]	|	0	     0	     0	     0	     19 	 0	     0	     27	     0	|
//	-------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;
		행		열		값		
	-------------------------
0	|	8	|	9	|	10	|
	-------------------------
1	|	0	|	1	|	20	|
2	|	0	|	4	|	9	|
3	|	0	|	7	|	11	|
4	|	2	|	0	|	78	|
5	|	3	|	4	|	67	|
6	|	4	|	1	|	31	|
7	|	5	|	3	|	91	|
8	|	5	|	6	|	44	|
9	|	7	|	4	|	19	|
10	|	7	|	7	|	27	|&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[스택(stack) & 큐(queue)]]></title><description><![CDATA[스택 (stack) 스택이란 쌓아올린다는 것을 의미하며, 원반 던지기 하듯 차곡차곡 쌓아올린 형태의 자료 구조를 의미한다. 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고 top…]]></description><link>https://graily0031.github.io/data_structure/stack_and_queue/</link><guid isPermaLink="false">https://graily0031.github.io/data_structure/stack_and_queue/</guid><pubDate>Sat, 12 Feb 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;스택 (stack)&lt;/h2&gt;
&lt;p&gt;스택이란 쌓아올린다는 것을 의미하며, 원반 던지기 하듯 차곡차곡 쌓아올린 형태의 자료 구조를 의미한다.&lt;br&gt;
같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고 top으로 정한 곳을 통해서만 접근할 수 있다. (쉽게 말해 입구가 하나밖에 없다 생각하면 쉽다.)&lt;br&gt;
top에는 가장 최근에 들어온 자료를 가리키고 있고 새 자료를 넣을 때 top이 가리키는 자료의 위에 쌓이게 된다. 삭제할 때 마찬가지로 top을 통해 가장 최근에 넣은 자료 먼저 삭제된다.&lt;br&gt;
top을 통해 삽입하는 연산을 &lt;code class=&quot;language-text&quot;&gt;push&lt;/code&gt;, 마찬가지로 top을 통해 삭제하는 연산을 &lt;code class=&quot;language-text&quot;&gt;pop&lt;/code&gt;이라 한다. 이러한 스택의 구조를 &lt;code class=&quot;language-text&quot;&gt;후입 선출&lt;/code&gt; 구조라 하며 줄여서 &lt;code class=&quot;language-text&quot;&gt;LIFO(last in first out)&lt;/code&gt;이라 부른다.&lt;br&gt;
만일 스택 저장공간에 데이터가 없는데 프로그램이 스택에서 데이터를 꺼내려고 할 경우 &lt;code class=&quot;language-text&quot;&gt;stack underflow&lt;/code&gt; 현상이 일어나게 되며, 반대로 스택 저장공간이 가득찼을 때 하나의 데이터를 더 넣고자 할 경우 &lt;code class=&quot;language-text&quot;&gt;stack overflow&lt;/code&gt; 현상이 일어나게 된다. 이 두 현상은 프로그램에 오류를 야기하게 된다.&lt;/p&gt;
&lt;h3&gt;스택 활용 예&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;웹 브라우저 뒤로가기&lt;/li&gt;
&lt;li&gt;역순 문자열 만들기&lt;/li&gt;
&lt;li&gt;후위 표기법 계산&lt;/li&gt;
&lt;li&gt;실행 취소(undo)…등등&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;스택 예시&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#define MAX_SIZE 5


int stack[MAX_SIZE];
int top = 0;


void push(int val) {
	if(top &amp;gt;= MAX_SIZE)
	{
		printf(&amp;quot;----overflow----&amp;quot;);
	}
	else
	{
		stack[top] = val;
		top ++;
	}
}

void pop() {
	if (top == 0)
	{
		printf(&amp;quot;----underflow&amp;quot;);
	}
	else
	{
		printf(&amp;quot;pop_%d\n&amp;quot;, stack[top - 1]);
		stack[top - 1] = 0;
		top--;
	}
}

void show() {
	int n;
	printf(&amp;quot;스택----------\n&amp;quot;);
	for(n = 0; n &amp;lt; MAX_SIZE; n++)printf(&amp;quot;%d\t&amp;quot;, stack[n]);
	
	printf(&amp;quot;\n&amp;quot;);
}

int main() {
	int act = 0;
	int data;
	
	printf(&amp;quot;명령어를 입력하세요\n&amp;quot;);
	printf(&amp;quot;1.push\t 2.pop\t 3.exit \n&amp;quot;);
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;act);
	
	switch(act)
	{
		case 1:
			printf(&amp;quot;insert push val : &amp;quot;);
			scanf(&amp;quot;%d&amp;quot;, &amp;amp;data);
			push(data);
			break;
		
		case 2:
			pop();
			break;
			
		case 3:
			act = 4;
			break;
			
		default:
			break;
	}
	show();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;큐 (queue)&lt;/h2&gt;
&lt;p&gt;큐는 예를 들어 은행의 번호표를 생각하면 쉽다. 창구에선 가장 먼저 번호표를 뽑은 사람의 업무를 처리해주는 것 처럼 선입선출 방식 즉 줄여서 &lt;code class=&quot;language-text&quot;&gt;FIFO(first in first out)&lt;/code&gt;방식의 자료구조이다.&lt;br&gt;
쉽게 생각해서 큐의 입구는 두개가 있다고 가정하면 된다. 한 쪽 끝에선 삽입 작업을 하고 다른 한 쪽 끝에선 삭제 작업이 이루어 지고 있다.&lt;br&gt;
삭제 연산만 수행되는 곳을 &lt;code class=&quot;language-text&quot;&gt;front&lt;/code&gt;, 삽입 연산만 수행되는 곳을 &lt;code class=&quot;language-text&quot;&gt;rear&lt;/code&gt;로 정해 각각의 연산작업만 수행된다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;rear&lt;/code&gt;에서 이루어지는 삽입연산을 &lt;code class=&quot;language-text&quot;&gt;enQueue&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;front&lt;/code&gt;에서 이루어지는 삭제연산을 &lt;code class=&quot;language-text&quot;&gt;deQueue&lt;/code&gt;라 부른다.&lt;br&gt;
접근 방법은 위에 설명했다 시피 가장 첫 원소와 끝 원소로만 가능하다. 즉 &lt;code class=&quot;language-text&quot;&gt;front&lt;/code&gt;에서는 가장 먼저 큐에 들어온 &lt;code class=&quot;language-text&quot;&gt;첫 번째 원소&lt;/code&gt;가 되며, &lt;code class=&quot;language-text&quot;&gt;rear&lt;/code&gt;에서는 가장 늦게 큐에 들어온 &lt;code class=&quot;language-text&quot;&gt;마지막 원소&lt;/code&gt;가 되는 것 이다.&lt;/p&gt;
&lt;h3&gt;큐 활용 예&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;은행 업무&lt;/li&gt;
&lt;li&gt;프로세스 관리&lt;/li&gt;
&lt;li&gt;너비 우선 탐색(BFS / breadth first search) 구현&lt;/li&gt;
&lt;li&gt;캐시(cache) 구현&lt;/li&gt;
&lt;li&gt;우선순위가 같은 작업의 예약 구현&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;큐 예시&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c++&quot;&gt;&lt;pre class=&quot;language-c++&quot;&gt;&lt;code class=&quot;language-c++&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#define MAX_SIZE 5


int queue[MAX_SIZE];
int front = -1;
int rear = -1;



int isEmpty(void) {
	if (front == rear)
	{
		return true;	
	 } 
	else
	{
		return false;
	}
}

void push(int val) {
	if ((rear + 1) % MAX_SIZE == front)
	{
		printf(&amp;quot;----isFull----\n&amp;quot;);
	}
	else
	{
		queue[++rear] = val;
	}
}

int pop() {
	if(isEmpty())
	{
		printf(&amp;quot;----isEmpty---\n&amp;quot;);
	}
	else
	{
		front = (front + 1) % MAX_SIZE;
		return queue[front];
	}
}


int main() {
	int act = 0;
	int data;
	
	printf(&amp;quot;명령어를 입력하세요\n&amp;quot;);
	printf(&amp;quot;1.push\t 2.pop\t 3.exit \n&amp;quot;);
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;act);
	
	switch(act)
	{
		case 1:
			printf(&amp;quot;insert push val : &amp;quot;);
			scanf(&amp;quot;%d&amp;quot;, &amp;amp;data);
			push(data);
			break;
		case 2:
			printf(&amp;quot;pop()-----&amp;gt;&amp;quot;);
			printf(&amp;quot;%d\n&amp;quot;, pop());
			break;
			
		case 3:
			act = 4;
			break;
			
		default:
			break;
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item></channel></rss>